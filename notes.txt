1. Go: 
    -> It is statically typed, compiled open source language programming language 
    -> designed by google.
    -> statically typed means value types are defined in advance (like we have to write variables types)
    -> compiled means code is compiled to machine code ahead of execution
    -> command: go run firstApp.go

2. Use:
    -> Go can be used to create all kinds of applications but it's especially
    -> popular for building scalable web servers or systems in general
    -> Go tries to combine the best of c++, java and python
    -> Engineers at google wanted to take performance of c++ but easier syntax and faster compilation time
    -> strict typing as in java and c++ for safety and unessary errors
    -> They also wanted the simplicity of python but better performance than python in some bigger projects
    -> They also wanted to a lot of built-in features,
    -> so that Go is ready to use without having to install a bunch of third-party libraries
    -> But they also wanted the great third-party support
    -> Go is awesome for web services and apps automation-scripts command line programs

3. When not to use it:
    -> Games, c++, unity is best for it.
    -> desktop apps, mobile apps

4. main():
    -> main is special function which is executed by default when we execute a file.

5. semicolon:
    -> ; is optional if not added during the compilation go will add these for you.
    -> convention is to omit them

6. data types:
    string: stores text, double quotes are reserved for strings. multiline strings in Go with the special ` (backtick) 
    int: number without decimal places
    float64: number with decimal places (more precise than float32 but takes more memory)
    float32: number with decimal places but takes less memory
    bool: stores boolean value
    byte: smallest possible storage unit, stores single character or more specifically single ascii character 
            internally any value in byte is stored as integer
            use single quotes for any value 
    rune: similar to byte but rune can store more characters. 
            here we are not limited to basic characters but we can also store emojis or anything like that
            internally any value in rune is stored as integer
            use single quotes for any value 
    

7. := operator 
    -> you always declare and define the variable in one step
    -> ("declare" means that you introduce the variable, "define" means that you assign a value to it).

8. var keyword
    -> If you create variables with the var keyword instead, 
    -> you can also declare + define in one step but you can also just declare the variable and define it at a later point of time
    -> var userName = "Max" // declaring + defining in one step
    -> var age int // declaring the variable
    -> age = 32 // defining a value for the variable

9. default variable value   
    -> the variable has a default value as an initial value - the so-called "null value".
    -> For int values, the default value is 0, for floats it's 0.0 and for string values (text), it's an empty string ("").

10. fmt package (formatting package)
    -> used for formatting and outputting strings
    -> fmt.Print(str), fmt.Printf(format, str), fmt.Println(str) 
    -> fmt.Printf("Hi My name is %v %v and my age is %v (Type: %T) years old", firstName, lastName, age, age)
    -> format string and output formatted string to standard output
    -> fmt.Srint(str), fmt.Srintf(format, str), fmt.Srintln(str) 
    -> format string and return formatted string
    -> fmt.Frint(str), fmt.Frintf(format, str), fmt.Frintln(str) 
    -> format string and write to specified writer


11. modules
    -> every .go file you create needs to belong to a package. (that's why package main)
    -> For bigger projects you might split up your projects into multiple packages 
    -> Go code is organized into modules and packages
    -> Modules are bigger than packages
    -> a module has a unique identifier and can be distributed(e.g library)
    -> every Go project goes into a new module
    -> projects can use(i.e import from) multiple modules (custom or third party)
    -> created and managed via Go mod commands and Go .mod file
    -> command: go mod init github.com/yourOrg/firstApp
    -> now to run command: go run . (it'll look for main package and main function)

12. packages
    -> every module contains atleast one package (the 'main' package)
    -> multiple files can make up the same package (via package instruction)
    -> a module may contain multiple packages, stored in subfolders
    -> can be imported

13. variable naming
    -> if you start the var name with lower case then it must be used in same package.
    -> to be used in other packages it must be started with uppercase.

14. const keyword
    -> to create constant variables
    -> const PI = 3.14
    -> function call cannot be assigned to const var
    -> because function will run inorder to get the value.
    -> but the const should be a value that's lockedIn before even app starts running

15. Reader
    -> To read data from the command prompt
    -> var reader = bufio.NewReader(os.Stdin);
    -> first create a reader instance
    -> reader.ReadString('\n');
    -> now this reader will capture the input whenever it encounters new line character 
    -> and it will also include it in captured string 


16. 'strings' library
    -> if we want to remove that newline char
    -> we can use 'strings' library
    -> strings.Replace(weightInput, "\n", "", -1)
    -> args[0] -> input which needs to be char replacement
    -> args[1] -> what's need to be replaced
    -> args[2] ->  with what
    -> args[3] -> how many instances should be replaced (-1 to replace all)

16. 'strconv' library
    -> to convert string data type to another data type
    -> usage: weight, _ := strconv.ParseFloat(weightInput, 32)

17. To print float value upto certain number of decimal
    -> usage: fmt.Printf("Your BMI: %.2f", bmi)


18. Generate random number
    -> import "math/rand"
    -> rand.Intn(n int)
    -> it will generate a random number b/w 0 and n, excluding n
    -> learn more about it: https://gobyexample.com/random-numbers

19. Functions
    -> functions in Go can return more than one value
    -> return num1, num2
    -> we will also have to declare the return type, if we are returning multiple values
    -> function getNumbers() (int, int) {}
    -> using named return value
    -> we can declare return var and use it inside the function
    -> then we don't have to return the variable 
    -> ex: function getNumbers() (a int, b int) {
    ->    a = 5
    ->    b = 10
    ->    return
    -> }
    -> see we didn't used a:=10, because the var is already declared
    -> and this function will automatically return two value a and b
    -> we don't have to specify it
    -> we should use this approach in short function
    -> we use it long functions with lot of variables it will become very confusing
    
20. Pointers
    -> Pointers are variables which does not store value but the memory address
    -> where the actual value is stored.
    -> Advantages
    -> when passed to functions(as parameters) unnessary value copies can be avoided
    -> function may directly work with / on an input value (e.g. change it)
    -> ex: age := 45; 
    ->     myAge := &age
    ->     fmt.Printf("Address: %p, Actual Value: %v", myAge, *myAge)
    -> getting the value using '*myAge' is called dereferencing
    -> because we are diving into the address and getting that value
    -> *myAge = 77 will override the actual value stored at age variable
    -> ex: func doubleAge(age *int) int {
	->         return *age * 2
    ->     }

21. struct
    -> user defined data type
    -> declaration: 
    -> type User struct {
            firstName   string
            lastName    string
            birthDate   string
            createdDate time.Time
        }
    -> instantiation: 
    -> newUser = User{
            firstName:   firstName,
            lastName:    lastName,
            birthDate:   birthdate,
            createdDate: created,
	    }
    -> if we keep the order same as declared in struct then we can instantiate like this
    -> newUser = User{
            firstName,
            lastName,
            birthdate,
            created,
        }
    -> if we call a function witha all the arguments required by the struct 
    -> and the function if creating the new object and returning it 
    -> in this case 2 instances of struct will be created
    -> first is the actual instance and other one is copy which is returned
    -> the first will be removed relatively quickly by garbage collector
    -> still if we have complex structs it can occupy lots of space
    -> To avoid this we can use pointers
    -> we can create object and return the pointer of it
    -> if we pass pointer to struct to another function
    -> we don't have to dereference it to access its properties
    -> so instead of (*user).firstName we can use user.firstName(go will dereference it for you) directly
    -> but both of them works
    -> we can connect a struct and a function(i.e make function method of struct)
    -> syntax: func (user User) outputDetails() {}
    -> we have added special reciever argument here
    -> and this reciever argument connects function to which type reciever argument is.

22. os.Create(filePath)
    -> is used to create file
    -> and we can also write data to this newly created file
    -> ex: file, _ := os.Create(prod.id+".txt")
           file.WriteString(content)
    
23. arrays
    -> declartion: [size]dataType{items}
    -> [4]float64{1.0, 2.99, 3.99, 4.0} or var prices [4]float64; prices = [4]float64{1.0, 2.99}

24. array slice method
    -> prices[1:3] will have elements from idx 1 to excluding 3
    -> prices[:3] will have elements from idx 0 to excluding 3
    -> prices[1:] will have all the elements starting idx 1
    -> if we create a new array by using slice on an array
    -> and override the values in the new array
    -> values in the original array will also gets modified
    -> so on slice a new array is not getting created but we are storing the just the references of part of the array
    -> ex: prices := [4]float64{1.0, 2.99, 3.99, 4.0}
           featuredPrices := prices[1:3]
           featuredPrices[0] = 199.99
           fmt.Println(prices) -> {1.0, 199.99, 3.99, 4.0}

25. len() inbuilt go function
    -> gives the number of elements in an array
    -> ex: len(prices)

26. cap() inbuilt go function
    -> gives the capacity of the array
    -> ex:  prices := [4]float64{1.0, 2.99, 3.99, 4.0}
	        featuredPrices := prices[1:]
	        highlightedPrices := featuredPrices[:1]
	        fmt.Println(len(highlightedPrices), cap(highlightedPrices)) -> 1 3
            highlightedPrices = highlightedPrices[:3]
            fmt.Println(highlightedPrices, len(highlightedPrices), cap(highlightedPrices)) -> [199.99 3.99 4] 3 3
    -> highlightedPrices are based on featuredPrices which in turn based on the prices
    -> so they share the same array under the hood 
    -> highlightedPrices only have one element because it starts at idx 1 and ends at idx 1
    -> but we have a heigher capacity
    -> because the original array on which highlightedPrices is based have more elements to its right
    -> for highlightedPrices we selected only one element(i.e [:1]) but theoratically we could select more elements
    -> and that's why we have the overall capacity of 3
    -> why not 4? since the original array has 4 elements
    -> because when we use slice we can select more towards the end of the array but not towards the start.
    -> we can also reslice and takes more elements from the right

27. Dynamic Lists With Slices
    -> we can create a dynamic slice by omitting the length: prices := []float64{1.99, 2.99}
    -> by creating a array like this go will automatically create a slice for you
    -> and since the slice is always based on an array
    -> it will also create an array for you behind the scenes
    -> but it will automatically ditch that array and create a new array if your slice grows beyond the bounds
    -> To append an element into the array: updatedPrices := append(prices, 5.33)
    -> but it will also return a brand new slice
    -> so it does not add it to the original slice but what append does is tells go that
    -> we want to add an item to the slice and therefore also to the underlying array
    -> and ofcourse an array has fixed length so what go will do in this case
    -> is it will create a brand new array and add that element into that brand new array
    -> which is created such that it has the capacity of that new array
    -> fmt.Println(updatedPrices, prices) -> [1.99 2.99 5.33] [1.99 2.99]
    -> to delete an element there is no inbuild function
    -> but we can use prices = prices[1:] to delete the first element
    -> append can take inifite number of arguments: append(prices, 5.99, 6.99, 7.99, 8.99)

28. unpacking list values
    -> syntax: discountPrices := []float64{101.99, 80.99, 100.10}
               prices := append(prices, discountPrices...) 
    -> ... pulls out all the elements in the array and use them as seperate elements

29. maps
    -> syntax: websites := map[string]string{"google": "https://google.com"}
    -> delete a key value pair: delete(websites, "google")

control structures

30. for loop
    -> syntax: for i := chosenNumber; i >= 1; i-- {}
    -> To iterate over an array: for idx, value := range inputNumbers {}

31. there is no while loop in go
    -> for isEnteringNumbers == true {}

32. split func
    -> strings.split(inputStr, ",")
    -> it returns a slice of string

33. 